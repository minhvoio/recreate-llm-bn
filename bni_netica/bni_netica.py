from __future__ import division
from __future__ import print_function
from builtins import range
from past.builtins import basestring
from past.utils import old_div
from builtins import object
import ctypes, re, itertools, sys, pdb, random, os, math
from ctypes import *

# SM: Removed licence from here (licence should only be kept with specific projects)
# TODO: add setLicense function
license = '+Site/MonashU/120,310-6-AS/47037'

def setLicense(_license = None):
	global license, env
	license = _license
	env = g.NewNeticaEnviron_ns(license, None, None)
	
def normalize(vec):
	total = 0
	newVec = vec[:]
	for i,v in enumerate(newVec):
		if v < 0:
			newVec[i] = 0
		else:
			total += v
	
	return [v/total for v in newVec]

class Net:
	MESG_LEN = 256
	NOTHING_ERR = 1
	ERROR_ERR = 5
	XXX_ERR = 6
	WILDCARD_STATE = -5
	UNDEF_STATE = -3
	UNDEFINED = None # Defined later
	INFINITY = None # Defined later


# Constants
class Node:
	# Types, as specified in "Netica.h"
	CONTINUOUS_TYPE, DISCRETE_TYPE, TEXT_TYPE = list(range(1,4))
	typeName = [0,'Continuous', 'Discrete', 'Text']
	# Kinds, as specified in "Netica.h"
	NATURE_NODE, CONSTANT_NODE, DECISION_NODE, UTILITY_NODE, DISCONNECTED_NODE = list(range(1,6))
	kindName = [0, 'Nature', 'Constant', 'Decision', 'Utility', 'Disconnected']

def NYI():
	print("nyi")

def msgBuf():
	return ctypes.create_string_buffer(bytes('\000' * 4000,'ascii'))

# SM: I need to clean this up, as I'm not sure which bits
# are actually required in which environments, and for which versions
# of python (but the chdir seems to help)
currentDir = os.path.abspath('.')
scriptDir = os.path.dirname(__file__)
sys.path.append(currentDir); 
sys.path.append(scriptDir)
if hasattr(os, 'add_dll_directory'):
	os.add_dll_directory(scriptDir)

if sys.platform == 'win32':
	os.environ['PATH'] += ';'+currentDir+';'+scriptDir
	os.chdir(scriptDir)
	try:
		g = ctypes.windll.LoadLibrary("./Netica64.dll")
	except:
		g = ctypes.windll.LoadLibrary("./Netica.dll")
	os.chdir(currentDir)
elif sys.platform.startswith('linux'):
	# I'm pretty sure LD_LIBRARY_PATH needs to be set before python is
	# loaded. I don't know a (non-ugly) workaround
	os.environ['LD_LIBRARY_PATH'] = currentDir+';'+scriptDir
	print("Loading Netica")
	os.chdir(scriptDir)
	g = ctypes.cdll.LoadLibrary('./libNeticaJ.so')
	os.chdir(currentDir)
else:
	print('Need platform specific library')

class c_simplechar_p(ctypes.c_char_p):
	@classmethod
	def from_param(cls, obj):
		return bytes(obj, 'ascii') if type(obj)==str else obj
	
	@classmethod
	def _check_retval_(cls, result):
		return result.value.decode('utf-8')
		
skipErrorChecks = set('ClearErrors_ns ClearError_ns ErrorCategory_ns ErrorSeverity_ns ErrorMessage_ns ErrorNumber_ns GetError_ns NewError_ns ReadNet_bn'.split(' '))

def cfunc(lib, funcName, restype, argtypes):
	func = getattr(lib, funcName)
	func.argtypes = argtypes
	func.restype = restype
	
	# I assume kwargs aren't supported, but just in case
	def checkCall(*args, **kwargs):
		#print(funcName, *args)
		res = func(*args)
		chkerr()
		return res
	
	if funcName not in skipErrorChecks:
		setattr(lib, funcName, checkCall)

# DON'T CHANGE --- Generated by makeBindings.py
checking_ns = ctypes.c_int
errseverity_ns = ctypes.c_int
errcond_ns = ctypes.c_int
eventtype_ns = ctypes.c_int
nodetype_bn = ctypes.c_int
nodekind_bn = ctypes.c_int
environ_ns = None
report_ns = None
stream_ns = None
randgen_ns = None
scripter_ns = None
net_bn = None
node_bn = None
nodelist_bn = None
caseset_cs = None
learner_bn = None
tester_bn = None
sensv_bn = None
setting_bn = None
dbmgr_cs = None
cfunc(g, "GetUndefDbl_ns", ctypes.c_double, [])
cfunc(g, "GetInfinityDbl_ns", ctypes.c_double, [])
state_bn = ctypes.c_int
prob_bn = ctypes.c_float
util_bn = ctypes.c_float
level_bn = ctypes.c_double
color_ns = ctypes.c_int
caseposn_bn = ctypes.c_long
bool_ns = ctypes.c_ubyte
sampling_bn = ctypes.c_int
learn_method_bn = ctypes.c_int
cfunc(g, "NewNeticaEnviron_ns", ctypes.POINTER(environ_ns), [c_simplechar_p, ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "InitNetica2_bn", ctypes.c_int, [ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "CloseNetica_bn", ctypes.c_int, [ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "GetNeticaVersion_bn", ctypes.c_int, [ctypes.POINTER(environ_ns), ctypes.POINTER(c_simplechar_p)])
cfunc(g, "ArgumentChecking_ns", checking_ns, [checking_ns, ctypes.POINTER(environ_ns)])
cfunc(g, "SetLanguage_ns", c_simplechar_p, [ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "LimitMemoryUsage_ns", ctypes.c_double, [ctypes.c_double, ctypes.POINTER(environ_ns)])
cfunc(g, "SetEnvironUserData_ns", None, [ctypes.POINTER(environ_ns), ctypes.c_int, ctypes.POINTER(None)])
cfunc(g, "GetEnvironUserData_ns", ctypes.POINTER(None), [ctypes.POINTER(environ_ns), ctypes.c_int])
cfunc(g, "GetError_ns", ctypes.POINTER(report_ns), [ctypes.POINTER(environ_ns), errseverity_ns, ctypes.POINTER(report_ns)])
cfunc(g, "ErrorNumber_ns", ctypes.c_int, [ctypes.POINTER(report_ns)])
cfunc(g, "ErrorMessage_ns", c_simplechar_p, [ctypes.POINTER(report_ns)])
cfunc(g, "ErrorSeverity_ns", errseverity_ns, [ctypes.POINTER(report_ns)])
cfunc(g, "ErrorCategory_ns", bool_ns, [errcond_ns, ctypes.POINTER(report_ns)])
cfunc(g, "ClearError_ns", None, [ctypes.POINTER(report_ns)])
cfunc(g, "ClearErrors_ns", None, [ctypes.POINTER(environ_ns), errseverity_ns])
cfunc(g, "NewError_ns", ctypes.POINTER(report_ns), [ctypes.POINTER(environ_ns), ctypes.c_int, errseverity_ns, c_simplechar_p])
cfunc(g, "TestFaultRecovery_ns", ctypes.c_int, [ctypes.POINTER(environ_ns), ctypes.c_int])
cfunc(g, "UserAllowed_ns", ctypes.c_int, [ctypes.POINTER(environ_ns), ctypes.c_int])
cfunc(g, "NewFileStream_ns", ctypes.POINTER(stream_ns), [c_simplechar_p, ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "NewMemoryStream_ns", ctypes.POINTER(stream_ns), [c_simplechar_p, ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "DeleteStream_ns", None, [ctypes.POINTER(stream_ns)])
cfunc(g, "SetStreamPassword_ns", None, [ctypes.POINTER(stream_ns), c_simplechar_p])
cfunc(g, "SetStreamContents_ns", None, [ctypes.POINTER(stream_ns), c_simplechar_p, ctypes.c_long, bool_ns])
cfunc(g, "GetStreamContents_ns", c_simplechar_p, [ctypes.POINTER(stream_ns), ctypes.POINTER(ctypes.c_long)])
cfunc(g, "WriteNet_bn", None, [ctypes.POINTER(net_bn), ctypes.POINTER(stream_ns)])
cfunc(g, "ReadNet_bn", ctypes.POINTER(net_bn), [ctypes.POINTER(stream_ns), ctypes.c_int])
cfunc(g, "WriteNetFindings_bn", caseposn_bn, [ctypes.POINTER(nodelist_bn), ctypes.POINTER(stream_ns), ctypes.c_long, ctypes.c_double])
cfunc(g, "ReadNetFindings2_bn", None, [ctypes.POINTER(caseposn_bn), ctypes.POINTER(stream_ns), bool_ns, ctypes.POINTER(nodelist_bn), ctypes.POINTER(ctypes.c_long), ctypes.POINTER(ctypes.c_double)])
cfunc(g, "SetCaseFileDelimChar_ns", ctypes.c_int, [ctypes.c_int, ctypes.POINTER(environ_ns)])
cfunc(g, "SetMissingDataChar_ns", ctypes.c_int, [ctypes.c_int, ctypes.POINTER(environ_ns)])
cfunc(g, "NewNet_bn", ctypes.POINTER(net_bn), [c_simplechar_p, ctypes.POINTER(environ_ns)])
cfunc(g, "CopyNet_bn", ctypes.POINTER(net_bn), [ctypes.POINTER(net_bn), c_simplechar_p, ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "DeleteNet_bn", None, [ctypes.POINTER(net_bn)])
cfunc(g, "GetNthNet_bn", ctypes.POINTER(net_bn), [ctypes.c_int, ctypes.POINTER(environ_ns)])
cfunc(g, "NewNode_bn", ctypes.POINTER(node_bn), [c_simplechar_p, ctypes.c_int, ctypes.POINTER(net_bn)])
cfunc(g, "CopyNodes_bn", ctypes.POINTER(nodelist_bn), [ctypes.POINTER(nodelist_bn), ctypes.POINTER(net_bn), c_simplechar_p])
cfunc(g, "DeleteNode_bn", None, [ctypes.POINTER(node_bn)])
cfunc(g, "SetNetName_bn", None, [ctypes.POINTER(net_bn), c_simplechar_p])
cfunc(g, "SetNetTitle_bn", None, [ctypes.POINTER(net_bn), c_simplechar_p])
cfunc(g, "SetNetComment_bn", None, [ctypes.POINTER(net_bn), c_simplechar_p])
cfunc(g, "SetNetElimOrder_bn", None, [ctypes.POINTER(net_bn), ctypes.POINTER(nodelist_bn)])
cfunc(g, "SetNetAutoUpdate_bn", ctypes.c_int, [ctypes.POINTER(net_bn), ctypes.c_int])
cfunc(g, "SetNetUserField_bn", None, [ctypes.POINTER(net_bn), c_simplechar_p, ctypes.POINTER(None), ctypes.c_int, ctypes.c_int])
cfunc(g, "SetNetUserData_bn", None, [ctypes.POINTER(net_bn), ctypes.c_int, ctypes.POINTER(None)])
cfunc(g, "SetNodeName_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "SetNodeTitle_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "SetNodeComment_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "SetNodeLevels_bn", None, [ctypes.POINTER(node_bn), ctypes.c_int, ctypes.POINTER(level_bn)])
cfunc(g, "SetNodeKind_bn", None, [ctypes.POINTER(node_bn), nodekind_bn])
cfunc(g, "SetNodeStateName_bn", None, [ctypes.POINTER(node_bn), state_bn, c_simplechar_p])
cfunc(g, "SetNodeStateNames_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "SetNodeStateTitle_bn", None, [ctypes.POINTER(node_bn), state_bn, c_simplechar_p])
cfunc(g, "SetNodeStateComment_bn", None, [ctypes.POINTER(node_bn), state_bn, c_simplechar_p])
cfunc(g, "SetNodeInputName_bn", None, [ctypes.POINTER(node_bn), ctypes.c_int, c_simplechar_p])
cfunc(g, "SetNodeEquation_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "SetNodeFuncState_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn), state_bn])
cfunc(g, "SetNodeFuncReal_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn), ctypes.c_double])
cfunc(g, "SetNodeProbs_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn), ctypes.POINTER(prob_bn)])
cfunc(g, "SetNodeExperience_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn), ctypes.c_double])
cfunc(g, "DeleteNodeTables_bn", None, [ctypes.POINTER(node_bn)])
cfunc(g, "SetNodeUserField_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p, ctypes.POINTER(None), ctypes.c_int, ctypes.c_int])
cfunc(g, "SetNodeUserData_bn", None, [ctypes.POINTER(node_bn), ctypes.c_int, ctypes.POINTER(None)])
cfunc(g, "SetNodeVisPosition_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(None), ctypes.c_double, ctypes.c_double])
cfunc(g, "SetNodeVisStyle_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(None), c_simplechar_p])
cfunc(g, "GetNetName_bn", c_simplechar_p, [ctypes.POINTER(net_bn)])
cfunc(g, "GetNetTitle_bn", c_simplechar_p, [ctypes.POINTER(net_bn)])
cfunc(g, "GetNetComment_bn", c_simplechar_p, [ctypes.POINTER(net_bn)])
cfunc(g, "GetNetNodes2_bn", ctypes.POINTER(nodelist_bn), [ctypes.POINTER(net_bn), c_simplechar_p])
cfunc(g, "GetNodeNamed_bn", ctypes.POINTER(node_bn), [c_simplechar_p, ctypes.POINTER(net_bn)])
cfunc(g, "GetNetFileName_bn", c_simplechar_p, [ctypes.POINTER(net_bn)])
cfunc(g, "GetNetAutoUpdate_bn", ctypes.c_int, [ctypes.POINTER(net_bn)])
cfunc(g, "GetNetElimOrder_bn", ctypes.POINTER(nodelist_bn), [ctypes.POINTER(net_bn)])
cfunc(g, "GetNetUserField_bn", c_simplechar_p, [ctypes.POINTER(net_bn), c_simplechar_p, ctypes.POINTER(ctypes.c_int), ctypes.c_int])
cfunc(g, "GetNetNthUserField_bn", None, [ctypes.POINTER(net_bn), ctypes.c_int, ctypes.POINTER(c_simplechar_p), ctypes.POINTER(c_simplechar_p), ctypes.POINTER(ctypes.c_int), ctypes.c_int])
cfunc(g, "GetNetUserData_bn", ctypes.POINTER(None), [ctypes.POINTER(net_bn), ctypes.c_int])
cfunc(g, "GetNodeNet_bn", ctypes.POINTER(net_bn), [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeName_bn", c_simplechar_p, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeTitle_bn", c_simplechar_p, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeComment_bn", c_simplechar_p, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeType_bn", nodetype_bn, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeKind_bn", nodekind_bn, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeNumberStates_bn", ctypes.c_int, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeLevels_bn", ctypes.POINTER(level_bn), [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeStateName_bn", c_simplechar_p, [ctypes.POINTER(node_bn), state_bn])
cfunc(g, "GetNodeStateTitle_bn", c_simplechar_p, [ctypes.POINTER(node_bn), state_bn])
cfunc(g, "GetNodeStateComment_bn", c_simplechar_p, [ctypes.POINTER(node_bn), state_bn])
cfunc(g, "GetStateNamed_bn", state_bn, [c_simplechar_p, ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeParents_bn", ctypes.POINTER(nodelist_bn), [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeChildren_bn", ctypes.POINTER(nodelist_bn), [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeInputName_bn", c_simplechar_p, [ctypes.POINTER(node_bn), ctypes.c_int])
cfunc(g, "GetInputNamed_bn", ctypes.c_int, [c_simplechar_p, ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeEquation_bn", c_simplechar_p, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeFuncState_bn", state_bn, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn)])
cfunc(g, "GetNodeFuncReal_bn", ctypes.c_double, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn)])
cfunc(g, "GetNodeProbs_bn", ctypes.POINTER(prob_bn), [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn)])
cfunc(g, "GetNodeExperience_bn", ctypes.c_double, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn)])
cfunc(g, "HasNodeTable_bn", bool_ns, [ctypes.POINTER(node_bn), ctypes.POINTER(bool_ns)])
cfunc(g, "IsNodeDeterministic_bn", bool_ns, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeUserField_bn", c_simplechar_p, [ctypes.POINTER(node_bn), c_simplechar_p, ctypes.POINTER(ctypes.c_int), ctypes.c_int])
cfunc(g, "GetNodeNthUserField_bn", None, [ctypes.POINTER(node_bn), ctypes.c_int, ctypes.POINTER(c_simplechar_p), ctypes.POINTER(c_simplechar_p), ctypes.POINTER(ctypes.c_int), ctypes.c_int])
cfunc(g, "GetNodeUserData_bn", ctypes.POINTER(None), [ctypes.POINTER(node_bn), ctypes.c_int])
cfunc(g, "GetNodeVisPosition_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(None), ctypes.POINTER(ctypes.c_double), ctypes.POINTER(ctypes.c_double)])
cfunc(g, "GetNodeVisStyle_bn", c_simplechar_p, [ctypes.POINTER(node_bn), ctypes.POINTER(None)])
cfunc(g, "AddLink_bn", ctypes.c_int, [ctypes.POINTER(node_bn), ctypes.POINTER(node_bn)])
cfunc(g, "DeleteLink_bn", None, [ctypes.c_int, ctypes.POINTER(node_bn)])
cfunc(g, "SwitchNodeParent_bn", None, [ctypes.c_int, ctypes.POINTER(node_bn), ctypes.POINTER(node_bn)])
cfunc(g, "IsNodeRelated_bn", bool_ns, [ctypes.POINTER(node_bn), c_simplechar_p, ctypes.POINTER(node_bn)])
cfunc(g, "GetRelatedNodes_bn", None, [ctypes.POINTER(nodelist_bn), c_simplechar_p, ctypes.POINTER(node_bn)])
cfunc(g, "GetRelatedNodesMult_bn", None, [ctypes.POINTER(nodelist_bn), c_simplechar_p, ctypes.POINTER(nodelist_bn)])
cfunc(g, "NewNodeList2_bn", ctypes.POINTER(nodelist_bn), [ctypes.c_int, ctypes.POINTER(net_bn)])
cfunc(g, "DeleteNodeList_bn", None, [ctypes.POINTER(nodelist_bn)])
cfunc(g, "ClearNodeList_bn", None, [ctypes.POINTER(nodelist_bn)])
cfunc(g, "LengthNodeList_bn", ctypes.c_int, [ctypes.POINTER(nodelist_bn)])
cfunc(g, "AddNodeToList_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(nodelist_bn), ctypes.c_int])
cfunc(g, "RemoveNthNode_bn", ctypes.POINTER(node_bn), [ctypes.POINTER(nodelist_bn), ctypes.c_int])
cfunc(g, "NthNode_bn", ctypes.POINTER(node_bn), [ctypes.POINTER(nodelist_bn), ctypes.c_int])
cfunc(g, "SetNthNode_bn", None, [ctypes.POINTER(nodelist_bn), ctypes.c_int, ctypes.POINTER(node_bn)])
cfunc(g, "IndexOfNodeInList_bn", ctypes.c_int, [ctypes.POINTER(node_bn), ctypes.POINTER(nodelist_bn), ctypes.c_int])
cfunc(g, "DupNodeList_bn", ctypes.POINTER(nodelist_bn), [ctypes.POINTER(nodelist_bn)])
cfunc(g, "ReviseCPTsByFindings_bn", None, [ctypes.POINTER(nodelist_bn), ctypes.c_int, ctypes.c_double])
cfunc(g, "ReviseCPTsByCaseFile_bn", None, [ctypes.POINTER(stream_ns), ctypes.POINTER(nodelist_bn), ctypes.c_int, ctypes.c_double])
cfunc(g, "FadeCPTable_bn", None, [ctypes.POINTER(node_bn), ctypes.c_double])
cfunc(g, "AddNodeStates_bn", None, [ctypes.POINTER(node_bn), state_bn, c_simplechar_p, ctypes.c_int, ctypes.c_double])
cfunc(g, "RemoveNodeState_bn", None, [ctypes.POINTER(node_bn), state_bn])
cfunc(g, "ReorderNodeStates_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn)])
cfunc(g, "EquationToTable_bn", None, [ctypes.POINTER(node_bn), ctypes.c_int, bool_ns, bool_ns])
cfunc(g, "ReverseLink_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(node_bn)])
cfunc(g, "AbsorbNodes_bn", None, [ctypes.POINTER(nodelist_bn)])
cfunc(g, "EnterFinding_bn", None, [ctypes.POINTER(node_bn), state_bn])
cfunc(g, "EnterFindingNot_bn", None, [ctypes.POINTER(node_bn), state_bn])
cfunc(g, "EnterNodeValue_bn", None, [ctypes.POINTER(node_bn), ctypes.c_double])
cfunc(g, "EnterNodeLikelihood_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(prob_bn)])
cfunc(g, "EnterNodeCalibration_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(prob_bn)])
cfunc(g, "EnterIntervalFinding_bn", None, [ctypes.POINTER(node_bn), ctypes.c_double, ctypes.c_double])
cfunc(g, "EnterGaussianFinding_bn", None, [ctypes.POINTER(node_bn), ctypes.c_double, ctypes.c_double])
cfunc(g, "GetNodeFinding_bn", state_bn, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeValueEntered_bn", ctypes.c_double, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeLikelihood_bn", ctypes.POINTER(prob_bn), [ctypes.POINTER(node_bn)])
cfunc(g, "RetractNodeFindings_bn", None, [ctypes.POINTER(node_bn)])
cfunc(g, "RetractNetFindings_bn", None, [ctypes.POINTER(net_bn)])
cfunc(g, "CalcNodeState_bn", state_bn, [ctypes.POINTER(node_bn)])
cfunc(g, "CalcNodeValue_bn", ctypes.c_double, [ctypes.POINTER(node_bn)])
cfunc(g, "CompileNet_bn", None, [ctypes.POINTER(net_bn)])
cfunc(g, "UncompileNet_bn", None, [ctypes.POINTER(net_bn)])
cfunc(g, "SizeCompiledNet_bn", ctypes.c_double, [ctypes.POINTER(net_bn), ctypes.c_int])
cfunc(g, "IsBeliefUpdated_bn", bool_ns, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeBeliefs_bn", ctypes.POINTER(prob_bn), [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeExpectedValue_bn", ctypes.c_double, [ctypes.POINTER(node_bn), ctypes.POINTER(ctypes.c_double), ctypes.POINTER(ctypes.c_double), ctypes.POINTER(ctypes.c_double)])
cfunc(g, "GetNodeExpectedUtils_bn", ctypes.POINTER(util_bn), [ctypes.POINTER(node_bn)])
cfunc(g, "FindingsProbability_bn", ctypes.c_double, [ctypes.POINTER(net_bn)])
cfunc(g, "GetNetExpectedUtility_bn", util_bn, [ctypes.POINTER(net_bn)])
cfunc(g, "JointProbability_bn", ctypes.c_double, [ctypes.POINTER(nodelist_bn), ctypes.POINTER(state_bn)])
cfunc(g, "MostProbableConfig_bn", None, [ctypes.POINTER(nodelist_bn), ctypes.POINTER(state_bn), ctypes.c_int])
cfunc(g, "NewSensvToFinding_bn", ctypes.POINTER(sensv_bn), [ctypes.POINTER(node_bn), ctypes.POINTER(nodelist_bn), ctypes.c_int])
cfunc(g, "DeleteSensvToFinding_bn", None, [ctypes.POINTER(sensv_bn)])
cfunc(g, "GetMutualInfo_bn", ctypes.c_double, [ctypes.POINTER(sensv_bn), ctypes.POINTER(node_bn)])
cfunc(g, "GetVarianceOfReal_bn", ctypes.c_double, [ctypes.POINTER(sensv_bn), ctypes.POINTER(node_bn)])
cfunc(g, "GenerateRandomCase_bn", ctypes.c_int, [ctypes.POINTER(nodelist_bn), sampling_bn, ctypes.c_double, ctypes.POINTER(randgen_ns)])
cfunc(g, "AddNodeToNodeset_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "RemoveNodeFromNodeset_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "IsNodeInNodeset_bn", bool_ns, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "GetAllNodesets_bn", c_simplechar_p, [ctypes.POINTER(net_bn), bool_ns, ctypes.POINTER(None)])
cfunc(g, "SetNodesetColor_bn", color_ns, [c_simplechar_p, color_ns, ctypes.POINTER(net_bn), ctypes.POINTER(None)])
cfunc(g, "ReorderNodesets_bn", None, [ctypes.POINTER(net_bn), c_simplechar_p, ctypes.POINTER(None)])
cfunc(g, "NewCaseset_cs", ctypes.POINTER(caseset_cs), [c_simplechar_p, ctypes.POINTER(environ_ns)])
cfunc(g, "DeleteCaseset_cs", None, [ctypes.POINTER(caseset_cs)])
cfunc(g, "AddFileToCaseset_cs", None, [ctypes.POINTER(caseset_cs), ctypes.POINTER(stream_ns), ctypes.c_double, c_simplechar_p])
cfunc(g, "WriteCaseset_cs", None, [ctypes.POINTER(caseset_cs), ctypes.POINTER(stream_ns), c_simplechar_p])
cfunc(g, "NewDBManager_cs", ctypes.POINTER(dbmgr_cs), [c_simplechar_p, c_simplechar_p, ctypes.POINTER(environ_ns)])
cfunc(g, "DeleteDBManager_cs", None, [ctypes.POINTER(dbmgr_cs)])
cfunc(g, "ExecuteDBSql_cs", None, [ctypes.POINTER(dbmgr_cs), c_simplechar_p, c_simplechar_p])
cfunc(g, "InsertFindingsIntoDB_bn", None, [ctypes.POINTER(dbmgr_cs), ctypes.POINTER(nodelist_bn), c_simplechar_p, c_simplechar_p, c_simplechar_p])
cfunc(g, "AddDBCasesToCaseset_cs", None, [ctypes.POINTER(caseset_cs), ctypes.POINTER(dbmgr_cs), ctypes.c_double, ctypes.POINTER(nodelist_bn), c_simplechar_p, c_simplechar_p, c_simplechar_p, c_simplechar_p])
cfunc(g, "AddNodesFromDB_bn", None, [ctypes.POINTER(dbmgr_cs), ctypes.POINTER(net_bn), c_simplechar_p, c_simplechar_p, c_simplechar_p, c_simplechar_p])
cfunc(g, "NewLearner_bn", ctypes.POINTER(learner_bn), [learn_method_bn, c_simplechar_p, ctypes.POINTER(environ_ns)])
cfunc(g, "DeleteLearner_bn", None, [ctypes.POINTER(learner_bn)])
cfunc(g, "SetLearnerMaxIters_bn", ctypes.c_int, [ctypes.POINTER(learner_bn), ctypes.c_int])
cfunc(g, "SetLearnerMaxTol_bn", ctypes.c_double, [ctypes.POINTER(learner_bn), ctypes.c_double])
cfunc(g, "LearnCPTs_bn", None, [ctypes.POINTER(learner_bn), ctypes.POINTER(nodelist_bn), ctypes.POINTER(caseset_cs), ctypes.c_double])
cfunc(g, "NewNetTester_bn", ctypes.POINTER(tester_bn), [ctypes.POINTER(nodelist_bn), ctypes.POINTER(nodelist_bn), ctypes.c_int])
cfunc(g, "DeleteNetTester_bn", None, [ctypes.POINTER(tester_bn)])
cfunc(g, "TestWithCaseset_bn", None, [ctypes.POINTER(tester_bn), ctypes.POINTER(caseset_cs)])
cfunc(g, "GetTestErrorRate_bn", ctypes.c_double, [ctypes.POINTER(tester_bn), ctypes.POINTER(node_bn)])
cfunc(g, "GetTestLogLoss_bn", ctypes.c_double, [ctypes.POINTER(tester_bn), ctypes.POINTER(node_bn)])
cfunc(g, "GetTestQuadraticLoss_bn", ctypes.c_double, [ctypes.POINTER(tester_bn), ctypes.POINTER(node_bn)])
cfunc(g, "GetTestConfusion_bn", ctypes.c_double, [ctypes.POINTER(tester_bn), ctypes.POINTER(node_bn), state_bn, state_bn])
cfunc(g, "SetNetNumUndos_bn", None, [ctypes.POINTER(net_bn), ctypes.c_int, ctypes.c_double, c_simplechar_p])
cfunc(g, "UndoNetLastOper_bn", ctypes.c_int, [ctypes.POINTER(net_bn), ctypes.c_double])
cfunc(g, "RedoNetOper_bn", ctypes.c_int, [ctypes.POINTER(net_bn), ctypes.c_double])
cfunc(g, "GetNodeLabel_bn", ctypes.c_int, [ctypes.POINTER(node_bn), ctypes.POINTER(ctypes.c_ushort), ctypes.c_int, c_simplechar_p])
cfunc(g, "GetNodeStateLabel_bn", ctypes.c_int, [ctypes.POINTER(node_bn), state_bn, ctypes.POINTER(ctypes.c_ushort), ctypes.c_int, c_simplechar_p])
cfunc(g, "CreateCustomReport_bn", c_simplechar_p, [ctypes.POINTER(net_bn), ctypes.POINTER(nodelist_bn), c_simplechar_p, c_simplechar_p])
cfunc(g, "ControlConcurrency_ns", c_simplechar_p, [ctypes.POINTER(environ_ns), c_simplechar_p, c_simplechar_p])
cfunc(g, "ControlNetCaching_bn", c_simplechar_p, [ctypes.POINTER(net_bn), c_simplechar_p, c_simplechar_p, ctypes.POINTER(nodelist_bn)])
cfunc(g, "ExpandNet_bn", ctypes.POINTER(net_bn), [ctypes.POINTER(net_bn), ctypes.c_int, ctypes.c_double, ctypes.c_double, c_simplechar_p])
cfunc(g, "SetNodeInputDelay_bn", None, [ctypes.POINTER(node_bn), ctypes.c_int, ctypes.c_int, c_simplechar_p])
cfunc(g, "SetNodePersistance_bn", None, [ctypes.POINTER(node_bn), ctypes.c_int, c_simplechar_p])
cfunc(g, "GetNodeAtTime_bn", ctypes.POINTER(node_bn), [ctypes.POINTER(net_bn), c_simplechar_p, ctypes.POINTER(ctypes.c_double)])
cfunc(g, "NewRandomGenerator_ns", ctypes.POINTER(randgen_ns), [c_simplechar_p, ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "DeleteRandomGen_ns", None, [ctypes.POINTER(randgen_ns)])
cfunc(g, "GetRandomGenState_ns", c_simplechar_p, [ctypes.POINTER(randgen_ns), c_simplechar_p])
cfunc(g, "GenerateRandomNumbers_ns", ctypes.c_double, [ctypes.POINTER(randgen_ns), ctypes.POINTER(ctypes.c_double), ctypes.c_int, c_simplechar_p])
cfunc(g, "SetNetRandomGen_bn", None, [ctypes.POINTER(net_bn), ctypes.POINTER(randgen_ns), bool_ns])
cfunc(g, "EnterAction_bn", None, [ctypes.POINTER(node_bn), state_bn])
cfunc(g, "EnterActionValue_bn", None, [ctypes.POINTER(node_bn), ctypes.c_double])
cfunc(g, "EnterActionRandomized_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(prob_bn)])
cfunc(g, "CleanupThreadEnding_ns", None, [ctypes.POINTER(environ_ns)])
cfunc(g, "NthProb_bn", ctypes.c_double, [ctypes.POINTER(prob_bn), state_bn])
cfunc(g, "NthLevel_bn", ctypes.c_double, [ctypes.POINTER(level_bn), state_bn])
cfunc(g, "GetChars_ns", ctypes.c_int, [c_simplechar_p, ctypes.c_int, ctypes.POINTER(ctypes.c_ushort), ctypes.c_int])
cfunc(g, "NthChar_ns", ctypes.c_int, [c_simplechar_p, ctypes.c_int])
cfunc(g, "SetNthState_bn", None, [ctypes.POINTER(state_bn), ctypes.c_int, state_bn])
cfunc(g, "OptimizeDecisions_bn", None, [ctypes.POINTER(nodelist_bn)])
cfunc(g, "NewNodeList_bn", ctypes.POINTER(nodelist_bn), [ctypes.c_int, ctypes.POINTER(environ_ns)])

# Errors, and error checking
# Note: internally, need to call chkerr() after every operation
ErrorCheckingOn = False
def NewError( number, severity, message):
	errorReport = c_void_p(g.NewError_ns(env, number, severity, byref(message)))
	return errorReport
def ClearError( error):
	g.ClearError_ns(error)
def ClearErrors( severity = Net.ERROR_ERR):
	g.ClearErrors_ns(env, severity)
def GetError( severity, after = None):
	if ErrorCheckingOn:
		res = g.GetError_ns(env, severity, after)
		if res: return c_void_p(res)
		else:   return None
def ErrorMessage( error):
	return g.ErrorMessage_ns(error)
def chkerr():
	if GetError(Net.ERROR_ERR):
		exceptionMsg = "PyNetica: Error in " + ErrorMessage(GetError(Net.ERROR_ERR))
		#res, mesg = CloseNetica()
		#print(mesg)
		# Try clearing the error:
		ClearErrors()
		raise BNIError(exceptionMsg)


env = g.NewNeticaEnviron_ns(license, None, None)
g.LimitMemoryUsage_ns(7000000000, env)
mesg = msgBuf()
g.InitNetica2_bn(env, mesg)
ErrorCheckingOn = True

class BNIError(Exception):
	def __init__(self, msg):
		self.msg = msg
	def __str__(self):
		return self.msg

class Net(Net):
	UNDEFINED = g.GetUndefDbl_ns()
	INFINITY = g.GetInfinityDbl_ns()

	def __init__(self, fn = "", autoUpdate = True):
		self.eNet = None # A pointer to the network as represented by the engine
		self._autoUpdate = True
	
		if fn:
			s = g.NewFileStream_ns(fn, env, None)
			self.eNet = g.ReadNet_bn(s, 0x10)
			# Will be null if error
			if self.eNet is None:
				chkerr()
			else:
				# Can still be error, but might have returned best net anyway,
				# in which case show error and proceed
				try:
					chkerr()
				except Exception as e:
					print("Error Reading Network:", e)
					# Check for one particular error (experience differing across rows without associated CPT)
					for node in self.nodes():
						if not g.HasNodeTable_bn(node.eId, bool_ns(0)):
							node.experience(1)
		else:
			self.eNet = c_void_p(g.NewNet_bn('untitled', env))
			chkerr()
		self.autoUpdate(autoUpdate)
	
	def __del__(self):
		g.DeleteNet_bn(self.eNet)
	
	def makeValidName(self, name, uniqueSet = [], maxLength = 30):
		IDREGEX = r'([_a-zA-Z])([_0-9a-zA-Z]{0,29})' # NOTE: Not anchored at start,end
		def makeName(s):
			try:
				s = re.sub(r'^[^_a-zA-Z]', r'_\g<0>', re.sub(r'[^_0-9a-zA-Z]', '_', str(s)))[:maxLength]
				# GeNIe crash on _ at start? Yes, why?
				s = re.sub(r'^_+', '', s)
				# Make sure it starts with letter
				s = re.sub(r'^([^a-zA-Z])', r's\1', s)[:maxLength]
				# Make sure empty states also have a letter
				if not s:  s = 's'
				return s
			except:
				pdb.set_trace()
				return None
		
		hasNode = True
		newName = makeName(name)
		i = 1
		uniqueSet = [(n.name() if hasattr(n,'name') else n) for n in uniqueSet]
		while hasNode:
			if newName not in uniqueSet:
				hasNode = False
			else:
				newName = newName[:maxLength-len(str(i))] + str(i)
			i += 1
			if i > 1000:
				pdb.set_trace()
				return None
		
		return newName

	# autoUpdate can be turned off for performance. You then need
	# to manually use 'update' after changes and before reading beliefs.
	def autoUpdate(self, autoUpdate = None):
		if autoUpdate is not None:
			g.SetNetAutoUpdate_bn(self.eNet, autoUpdate)
			self._autoUpdate = autoUpdate
			self.compile()
		else:
			return self._autoUpdate

	# Trigger update if not auto-updating
	def update(self):
		if not self._autoUpdate:
			# Just set and unset autoupdate to get a single belief update
			self.autoUpdate(True)
			self.autoUpdate(False)
		
	def name(self, _name = None):
		if _name is None:
			return g.GetNetName_bn(self.eNet)
		else:
			g.SetNetName_bn(self.eNet, _name)
			
		return self
			
	def title(self, _title = None):
		if _title is None:
			return g.GetNetTitle_bn(self.eNet)
		else:
			g.SetNetTitle_bn(self.eNet, _title)
			
		return self
	
	def write(self, fn):
		s = g.NewFileStream_ns(fn, env, None)
		g.WriteNet_bn(self.eNet, s)
		
	def node(self, name):
		nodePtr = g.GetNodeNamed_bn(name, self.eNet)
		chkerr()
		return Node(eNodePtr = nodePtr, net = self) if nodePtr is not None else None

	def addNode(self, name, states = None, levels = None, nodeType = None):
		return Node(self, name, states = states, levels = levels, nodeType = nodeType)
	
	def compile(self):
		g.CompileNet_bn(self.eNet)
		chkerr()
		return self
	
	def retractFindings(self):
		g.RetractNetFindings_bn(self.eNet)
		chkerr()
		
	def findings(self, findings = None, stateType = 'index'):
		if findings is None:
			findings = {}
			for node in self.nodes():
				f = node.finding()
				if f is not None:
					if stateType == 'name':
						findings[node.name()] = node.state(f).name()
					else: # index
						findings[node.name()] = f
			
			return findings
		else:
			for nodeName,finding in findings.items():
				if finding is None:
					self.node(nodeName).retractFindings()
				else:
					self.node(nodeName).finding(finding)
		
		return self
	
	def nodes(self):
		nodeList = g.GetNetNodes2_bn(self.eNet, None)
		numNodes = g.LengthNodeList_bn(nodeList)

		return [Node(self,eNodePtr=g.NthNode_bn(nodeList, i)) for i in range(numNodes)]
		
	def findingsProbability(self):
		return g.FindingsProbability_bn(self.eNet)

	# Not sure these belong here
	@classmethod
	def numberCombinations(cls, nodes):
		total = 1

		for i in range(len(nodes)):
			total *= nodes[i].numberStates()

		return total

	# This function works for discrete nodes only, of course
	# nodeStates should be an array the size of len(nodes)
	@classmethod
	def nextCombination(cls, nodeStates, nodes, skip = []):
		# Flip skip array (which also makes it a dict)
		fs = {}
		for i,v in enumerate(skip): fs[v] = skip[i]
		skip = fs
		
		numNodes = len(nodeStates)
		for i in range(numNodes-1,-1,-1):
			if i in skip: continue
			nodeStates[i] += 1
			if nodeStates[i] >= nodes[i].numberStates():
				# Set the i^th node state to 0 and continue to next node
				nodeStates[i] = 0
			else:
				# More combinations to come
				return True
		# All node states have rolled back round to 0
		return False
		
	# This probably works more nicely than nextCombination for most use cases
	def CombinationIterator(net, nodes, returnType = 'indexes'):
		nodes = [net.node(s) if isinstance(s,str) else s for s in nodes]
		# Get the arity for each node
		nodeArities = [n.numberStates() for n in nodes]
		
		# |nodeStates| is our "odometer"
		# Initialise the odometer to all zeroes
		nodeStates = [0]*len(nodes)
		
		# Loop through every row in the CPT
		hasMore = True
		while hasMore:
			# We are using generators, so we can pause
			# and re-start the function. Each time, we
			# yield the current state of the odometer
			if returnType == 'indexes':
				yield nodeStates
			elif returnType == 'names':
				yield [node.state(s).name() for node,s in zip(nodes,nodeStates)]
			elif returnType == 'dict':
				yield {node.name():node.state(s).name() for node,s in zip(nodes,nodeStates)}
			elif returnType == 'dictTitle':
				yield {(node.title() or node.name()):node.state(s).name() for node,s in zip(nodes,nodeStates)}
			
			# On each loop, increment the odometer
			hasMore = False
			for i in range(len(nodeStates)-1,-1,-1):
				nodeStates[i] += 1
				# If we don't need to "Carry the 1", stop
				if nodeStates[i] < nodeArities[i]:
					hasMore = True
					break

				# Otherwise, carry the 1 and keep looping
				nodeStates[i] = 0

	# Learning. Default is 'Count'. Pass type = 'EM' or type = 'GradientDescent' for those.
	# For EM, you'll need to specify which nodes you want to start randomized.
	def learn(self, fileName, type = 'EM', degree = 1, nodes = None,
			maxIterations = 1000, maxTolerance = 1e-5, removeTables = False,
			randomize = None, uniformize = None):
		# If an empty list of nodes specified, then don't do anything
		if nodes == []:  return
		
		nodes = list(nodes or self.nodes()) # Default to all nodes
		if len(nodes) and isinstance(nodes[0],str):
			errorNames = []
			for i,n in enumerate(nodes):
				if self.node(n) is None:
					errorNames.append(n)
				nodes[i] = self.node(n)
			if errorNames:
				raise Exception(f'''Cannot find nodes named "{'","'.join(errorNames)}"''')
		
		methods = {
			'Count': 1,
			'EM': 3,
			'GradientDescent': 4,
		}
		
		# # For CSVs, extract all field names
		# if os.path.splitext(fileName)[1].lower()=='.csv':
			# fieldNames = None
			# with open(fileName) as tempFile:
				# inCsv = csv.DictReader(tempFile)
				# fieldNames = inCsv.fieldnames
		
		# Make caseset from file
		stream = g.NewFileStream_ns(fileName, env, None)
		caseSet = g.NewCaseset_cs('training', env)
		g.AddFileToCaseset_cs(caseSet, stream, 1, None)
		
		# Make a learner object
		learner = g.NewLearner_bn(methods[type], None, env)
		
		# Make list of nodes
		nodeList = g.NewNodeList2_bn(len(nodes), self.eNet)
		for i,node in enumerate(nodes):
			if removeTables:
				g.DeleteNodeTables_bn(node.eId)
			
			g.SetNthNode_bn(nodeList, i, node.eId)
		
		if uniformize:
			if uniformize == True:
				uniformize = nodes
			for uNode in uniformize:
				if isinstance(uNode,str):
					uNode = self.node(uNode)
				if uNode is not None:
					uNode.setUniform()
					uNode.experience(1)
		
		if randomize:
			if randomize == True:
				randomize = nodes
			for rNode in randomize:
				if isinstance(rNode,str):
					rNode = self.node(rNode)
				if rNode is not None:
					rNode.setRandom()
					rNode.experience(1)
		
		# Set maximum iterations and tolerance (i.e. threshold for log likelihood for termination)
		g.SetLearnerMaxIters_bn(learner, maxIterations)
		g.SetLearnerMaxTol_bn(learner, maxTolerance)
		
		self.compile()
		# Now learn!
		g.LearnCPTs_bn(learner, nodeList, caseSet, degree)
		
		# Chaining
		return self
	
	# Sets experience for all nodes that have CPTs
	def experience(self, experience, force = False):
		for node in self.nodes():
			if force or g.HasNodeTable_bn(node.eId, None):
				if node.kind() not in [Node.UTILITY_NODE]:
					node.experience(experience = experience)
		
		return self
	
	# Retract findings before (and after), if needed
	def generateCase(self, timeout = 5000):
		nodeList = g.GetNetNodes2_bn(self.eNet, None)
		numNodes = g.LengthNodeList_bn(nodeList)
		
		if not hasattr(self, 'randGen'):
			self.randGen = g.NewRandomGenerator_ns(f"{random.randint(0,100000000)}", env, None)
		
		g.GenerateRandomCase_bn(nodeList, 0, timeout, self.randGen) # DEFAULT_SAMPLING, default rand gen
		
		return self

	# XXX-SM-2021-07-06: This needs work and to be cleaned up (and see the CAT/node.js version), but better
	# here than nowhere
	def sensitivityToFindings(self, targetNode, mi = True, expRankChange = True, nodes = None,
			targetAsSource = False, keyType = 'index'):
		targetNode = self.node(targetNode)
		net = self
		# t = time.time()
		
		nodes = nodes or net.nodes()
		
		origFindings = self.findings()
		
		# Get marginals (with whatever current evidence is)
		marginals = {}
		# print('a', time.time() - t)
		for node in nodes:
			marginals[node.name()] = node.beliefs()
		
		# Store all node beliefs for every different state in target
		beliefsByTargetState = []
		# print('b', time.time() - t)
		for state in targetNode.states():
			state.setTrueFinding()
			beliefs = {}
			for node in nodes:
				# The below is wrong, as it requires the marginals to be recomputed as well
				# if node.name() != targetNode.name() and node.hasFinding():
					# saved = node.finding()
					# node.retractFindings()
					# beliefs[node.name()] = node.beliefs()
					# node.finding(saved)
				# else:
					# beliefs[node.name()] = node.beliefs()
				beliefs[node.name()] = node.beliefs()
			beliefsByTargetState.append(beliefs)
		# print('c', time.time() - t)
		targetNode.retractFindings()
		
		
		# Now, calculate the MI table
		miTable = []
		targetMarginals = marginals[targetNode.name()]
		targetEntropy = sum(-p*math.log(p,2) for p in [max(0.00001,p) for p in marginals[targetNode.name()]])
		targetCondProbs = {}
		for node in nodes:
			# joint * log ( joint / marginals)
			# For each prob in target marginal
			total = 0
			targetCondProbs[node.name()] = [[0 for s2 in targetNode.states()] for s in node.states()]
			for i,targetMarginalProb in enumerate(targetMarginals):
				nodeMarginal = marginals[node.name()]
				# And each prob in both marginal and conditional node beliefs
				for j,nodeProb in enumerate(beliefsByTargetState[i][node.name()]):
					jointProb = targetMarginalProb*nodeProb
					nodeMarginalProb = nodeMarginal[j]
					
					if jointProb * targetMarginalProb * nodeMarginalProb != 0:
						#print(node.name(), jointProb, targetMarginalProb, nodeMarginalProb)
						total += jointProb * math.log( jointProb / (targetMarginalProb * nodeMarginalProb), 2 )
						
						targetCondProb = jointProb / nodeMarginalProb
					else:
						targetCondProb = 0
					
					targetCondProbs[node.name()][j][i] = targetCondProb
					#.append([i, node.name(), j, targetCondProb])
			
			miProp = total/targetEntropy
			
			minExpRank = 10000000
			maxExpRank = -1
			minExpRankJ = -1
			maxExpRankJ = -1
			if targetAsSource:
				# Get, for every target state, the current node's beliefs (conditional on target state)
				nodeProbs = [nodeBels[node.name()] for nodeBels in beliefsByTargetState]
			else:
				# Get, for every node state, the target's beliefs (conditional on node state)
				nodeProbs = targetCondProbs[node.name()]
				
			for j,row in enumerate(nodeProbs):
				expRank = sum(i*p for i,p in enumerate(row))
				if expRank < minExpRank:
					minExpRank = expRank
					minExpRankJ = j
				if expRank > maxExpRank:
					maxExpRank = expRank
					maxExpRankJ = j
			miTable.append([node.name(), total, miProp, maxExpRank-minExpRank, minExpRankJ, maxExpRankJ, str(node.title().encode('ascii',errors='ignore'), 'ascii')])
		
		#print(json.dumps(targetCondProbs, indent='\t'))
		
		self.findings(origFindings)
		
		miTable = sorted(miTable, key = lambda x: x[1], reverse=True)
		if keyType == 'index':
			return miTable
		elif keyType == 'name':
			return dict([entry[0], entry[1:]] for entry in miTable)

	# Just a helper function for sensitivityToFindings
	# XXX: Doesn't belong here
	def sensTableToHtml(self, sensTable, colors = True):
		from htm import n
		table = n('table', n('tr', n('th', 'Node'), n('th', 'MI'), n('th', 'MI Prop'), n('th', 'Max Exp Rank Change')))
		NAME = 0
		TITLE = 6
		MI = 1
		MIPROP = 2
		RANKCHANGE = 3
		
		minMi = 0
		maxMi = 0
		minRankChange = 0
		maxRankChange = 0
		for i,row in enumerate(sensTable):
			if i==0:  continue
			maxMi = max(row[MI], maxMi)
			print(row[RANKCHANGE])
			maxRankChange = max(row[RANKCHANGE], maxRankChange)
		print(maxRankChange)
		
		for row in sensTable:
			displayRow = row[:RANKCHANGE+1]
			displayRow[RANKCHANGE] = math.copysign(row[RANKCHANGE], row[RANKCHANGE+1]-row[RANKCHANGE])
			displayRow[NAME] = row[TITLE]
			tr = n('tr')
			for i,v in enumerate(displayRow):
				intensity = None
				if i==MI:
					intensity = (v-minMi)/(maxMi-minMi)
				elif i==RANKCHANGE:
					intensity = (abs(v)-minRankChange)/(maxRankChange-minRankChange)
				try:
					fmtVal = f'{float(v):.4f}'
				except:
					fmtVal = v
				tr.append(n('td', fmtVal, style=f'--intensity: {intensity}' if intensity is not None else ''))
			table.append(tr)
		
		return table

	def user(self):
		return UserProperties(self)

class Node(Node):
	def __init__(self, net = None, name = None, states = None, levels = None, nodeType = None, eNodePtr = None):
		self.net = net
		self.eId = eNodePtr # The node pointer in Netica (for the given net)
		
		# If all states are actually floats, assume they are levels
		if states is not None:
			def isFloat(x): return isinstance(x,float) or isinstance(x,int)
			if sum(not isFloat(s) for s in states) == 0:
				levels = states
				states = []
		
		if self.eId is None:
			numStates = 0
			if nodeType == Node.CONTINUOUS_TYPE or levels is not None:
				# Can have 0 states, or multiple states
				pass
			elif nodeType is None or nodeType == Node.DISCRETE_TYPE:
				if not states:
					states = ["state0", "state1"]
				numStates = len(states)
				
			if name is not None:
				if not self.checkValidName(name):
					raise BNIError("Node name "+repr(name)+" is not valid. Must have " +
						"first character as letter/underscore, "+
						"other characters as letter/number/underscore and max. 30 characters")
				self.eId = g.NewNode_bn(name, numStates, self.net.eNet)
				chkerr()

				# XXX: Set node type to be done
				if nodeType: pass

			if states:  self.renameStates(states)
			if levels:  self.levels(levels)
		
		chkerr()
	
	def checkValidName(self, name):
		# Netica convention: first character is letter/underscore,
		# other characters are letter/number/underscore
		# Max 30 characters
		if re.match(r'[a-zA-Z_][a-zA-Z0-9_]{,29}', name):
			return True
		else:
			return False
			
	def name(self):
		return g.GetNodeName_bn(self.eId)
					
	#OW: added set node title functionality 7/9/20
	def title(self, _title = None):
		if _title is None:
			return g.GetNodeTitle_bn(self.eId)
		else:
			g.SetNodeTitle_bn(self.eId, _title)
			
		return self
		
	def type(self, _type = None):
		if _type is None:
			return g.GetNodeType_bn(self.eId)
		else:
			nyi()
			# g.SetNodeType_bn(self.eId, _type)
			# SM (2020-09-07): SetNodeType doesn't exist. Not sure if there's another way to add it
		
		return self
	
	def levels(self, _levels = None):
		if _levels is None:
			numList = g.GetNodeLevels_bn(self.eId)
			#pdb.set_trace()
			levels = [numList[i] for i in range(self.numberStates()+1)]
			
			return levels
		else:
			n = len(_levels)
			numList = (c_double*n)(*_levels)
		
			g.SetNodeLevels_bn(self.eId, n-1, numList)
			chkerr()
		
		return self
	
	#levels didn't work for discrete nodes
	def values(self, _values = None):
		if _values is None:
			numList = g.GetNodeLevels_bn(self.eId)
			#pdb.set_trace()
			levels = [numList[i] for i in range(self.numberStates()+1)]
			
			return levels
		else:
			n = len(_values)
			numList = (c_double*n)(*_values)
		
			g.SetNodeLevels_bn(self.eId, n, numList)
			chkerr()
		
		return self
		
	def kind(self, _kind = None):
		if _kind is None:
			return g.GetNodeKind_bn(self.eId)
		else:
			g.SetNodeKind_bn(self.eId, _kind)
		
		return self
		
	def parents(self):
		nodeList = g.GetNodeParents_bn(self.eId)
		numParents = g.LengthNodeList_bn(nodeList)

		parents = []
		for i in range(numParents):
			parents.append(Node(self.net, eNodePtr=g.NthNode_bn(nodeList, i)))
		return parents
		
	def children(self):
		nodeList = g.GetNodeChildren_bn(self.eId)
		numChildren = g.LengthNodeList_bn(nodeList)

		children = []
		for i in range(numChildren):
			children.append(Node(self.net, eNodePtr=g.NthNode_bn(nodeList, i)))
		return children
	
	def getRelated(self, relation):
		nodeList = g.NewNodeList2_bn(0, self.net.eNet)
		g.GetRelatedNodes_bn(nodeList, relation, self.eId)
		numNodes = g.LengthNodeList_bn(nodeList)
		
		return [Node(self,eNodePtr=g.NthNode_bn(nodeList, i)) for i in range(numNodes)]
		
	def addParents(self, parents):
		"""
		Each element of parents can be an existing node name or node.
		"""
		for parent in parents:
			# Make sure each parent is a Node object
			if isinstance(parent, basestring):
				parent = self.net.node(parent)
			g.AddLink_bn(parent.eId, self.eId)
			chkerr()
		
		# Allow the call chain to continue
		return self
		
	def addChildren(self, children):
		"""
		Each element of children can be an existing node name or node.
		"""
		for child in children:
			# Make sure each child is a Node object
			if isinstance(child, basestring):
				child = self.net.node(child)
			g.AddLink_bn(self.eId, child.eId)
			chkerr()

		# Allow the call chain to continue
		return self
	
	def removeParents(self, parents):
		myParents = self.parents()
		toRemove = []
		for parent in parents:
			# Make sure each parent is a Node object
			if isinstance(parent, basestring):
				parent = self.net.node(parent)
			# Find index (will change each time)
			for i,myParent in enumerate(myParents):
				if myParent.name() == parent.name():
					toRemove.append(i)
					break
		
		for i in sorted(toRemove, reverse=True):
			g.DeleteLink_bn(i, self.eId)
		
		return self
	
	def removeChildren(self, children):
		for child in children:
			# Make sure each child is a Node object
			if isinstance(child, basestring):
				child = self.net.node(child)
			# Find index in child's parents
			for i,childParent in enumerate(child.parents()):
				if childParent.name() == self.name():
					g.DeleteLink_bn(i, child.eId)
					break
		
		return self
	
	# XXX: case can't be set yet
	# 'case' specifies whether to be case sensitive.
	def state(self, name = None, value = None, case = True, expandBounds = False):
		if value is not None:
			levels = self.levels() #g.GetNodeLevels_bn(self.eId)
			# 2021-11-10-SM: Levels can be in descending order
			# 2022-07-09-SM: To match Netica precisely, if a number falls into two bins, it's always
			# in the bin in which it would have the lowest value (so if ascending, the last bin;
			# if descending, the first bin)
			cmp = lambda a,b: a < b
			if len(levels)>=2 and levels[0] > levels[1]:
				cmp = lambda a,b: a >= b
			
			for i,val in enumerate(levels):
				#OW: <= changed to < 6/9/20
				if cmp(value, val):
					#OW: i changed to i-1 6/9/20
					name = i-1
					break
			
			if expandBounds:
				if name == -1:  name = 0
				elif name is None:  name = len(levels)-2
			
		# If we haven't identified a state reference at all yet, return None
		if name is None:
			return None
		
		# If int (assumed if not basestring), then just get state
		if not isinstance(name,basestring):
			return State(self,name)
		
		if case:
			stateI = g.GetStateNamed_bn(name, self.eId)
			if stateI == Net.UNDEF_STATE:
				return None
		else:
			try:
				return State(self, self.stateNames(case=False).index(name.lower()))
			except:
				return None
		
		return State(self, stateI)
		
	def states(self):
		return [State(self,i) for i in range(self.numberStates())]
	
	def stateByTitle(self, title):
		for state in self.states():
			if state.title() == title:
				return state
		
		return None
		
	def hasState(self, name):
		if self.state(name) is None:
			return False
		
		return True
	
	def addState(self, name):
		g.AddNodeStates_bn(self.eId, -1, name, 1, ctypes.c_double(-1.0))
		
		# Chain
		return self
	
	def renameState(self, name, newName):
		g.SetNodeStateName_bn(self.eId, self.state(name).stateNum, newName)
		chkerr()
		
		# Chain
		return self
		
	def renameStates(self, newNames):
		g.SetNodeStateNames_bn(self.eId, ",".join(newNames))
		chkerr()
		
		# Chain
		return self
	
	def reorderStates(self, ordering):
		# Netica does this the opposite of what I would have thought, and GeNIe agrees, so reverse these
		newOrdering = [0]*len(ordering)
		for i,v in enumerate(ordering):
			v = self.state(v).stateNum
			newOrdering[v] = i
		ordering = newOrdering
		
		g.ReorderNodeStates_bn(self.eId, (c_int*len(ordering))(*ordering))
		
		return self
	
	# Obviously, Netica's equation format is totally different to GeNIe's
	def equation(self, equationStr = None):
		if not equationStr:
			return g.GetNodeEquation_bn(self.eId)
		else:
			g.SetNodeEquation_bn(self.eId, equationStr)
	
		return self
		
	# parentStates=None will set experience for full CPT (default)
	def experience(self, experience = None, parentStates = None, cellCounts = False):
		def getRowOrVal(parentStates):
			parentStates = (state_bn*len(parentStates))(*parentStates)
			expValue = g.GetNodeExperience_bn(self.eId, parentStates)
			if cellCounts:
				row = self.cpt1d(parentStates = parentStates)
				row = [v*expValue for v in row]
				return row
			else:
				return expValue
		if experience is None:
			if parentStates is None:
				experienceTable = []
				for parentStates in self.net.CombinationIterator(self.parents()):
					experienceTable.append(getRowOrVal(parentStates))
					#print(parentStates)
				#print(experienceTable)
				return experienceTable
			else:
				return getRowOrVal(parentStates)
		else:
			numParents = len(self.parents())
			if parentStates is None and numParents:
				parentStates = [-5 for p in self.parents()] # -5 = every state
			if parentStates is not None:
				parentStates = (state_bn*numParents)(*parentStates)
			
			if isinstance(experience,list):
				for parentStates,expRow in zip(self.net.CombinationIterator(self.parents()),experience):
					parentStates = (state_bn*len(parentStates))(*parentStates)
					g.SetNodeExperience_bn(self.eId, parentStates, expRow)
			else:
				g.SetNodeExperience_bn(self.eId, parentStates, experience)
		
		return self
	
	def numberStates(self):
		return g.GetNodeNumberStates_bn(self.eId)
		
	def retractFindings(self):
		g.RetractNodeFindings_bn(self.eId)
		chkerr()
	
	def likelihoods(self, likelihoodVector = None):
		if likelihoodVector is None:
			lk = g.GetNodeLikelihood_bn(self.eId)
			return [lk[i] for i in range(self.numberStates())]
		else:
			chkerr()
			from struct import pack
			n = len(likelihoodVector)
			fp = (ctypes.c_float*n)(*likelihoodVector)
			g.EnterNodeLikelihood_bn(self.eId, fp)
			chkerr()
	
	def finding(self, state = None, value = None, ignoreErrors = False, expandBounds = False):
		stateOb = None
		if value is not None:
			#OW: cast value to float 6/9/20
			stateOb = self.state(value = float(value), expandBounds = expandBounds)
		elif state is not None:
			stateOb = self.state(state)
		
		if value is None and state is None:
			nodeFinding = g.GetNodeFinding_bn(self.eId)
			if nodeFinding == -3:
				return None
			elif nodeFinding == -6:
				return self.likelihoods()
			# Handle real-valued in some way
			#elif 
			
			return nodeFinding
				
		else:
			if stateOb is None:
				if not ignoreErrors:
					raise BNIError(f"Couldn't find a match state for '{self.name()}' given '{state if state is not None else value}'")
			else:
				stateOb.setTrueFinding()
		
		return self
		
	def findingByTitle(self, stateTitle):
		state = self.stateByTitle(stateTitle)
		if state is None:
			state = self.state(stateTitle)
		state.setTrueFinding()
		
		return self
		
	def expectedUtils(self):
		if not self.net._autoUpdate:
			self.net.update()
		
		eu = g.GetNodeExpectedUtils_bn(self.eId)
		chkerr()
		return [eu[i] for i in range(self.numberStates())]

	def beliefs(self):
		if not self.net._autoUpdate:
			self.net.update()
		
		p = g.GetNodeBeliefs_bn(self.eId)
		chkerr()
		return [p[i] for i in range(self.numberStates())]
		
	def expectedValue(self):
		if not self.net._autoUpdate:
			self.net.update()
		
		ev = g.GetNodeExpectedValue_bn(self.eId, None, None, None)
		chkerr()
		
		return ev
	
	def expectedUtilities(self):
		if not self.net._autoUpdate:
			self.net.update()
		
		eu = g.GetNodeExpectedUtils_bn(self.eId)
		chkerr()
		
		return [eu[i] for i in range(self.numberStates())]
		
	def probs(self, parentStates):
		NYI()

	def stateNames(self, case = True):
		caseFunc = (lambda x:x) if case else (lambda x:x.lower())
		return [caseFunc(g.GetNodeStateName_bn(self.eId, i)) for i in range(self.numberStates())]
	
	def position(self, x = None, y = None):
		if x is None:
			# Possible Netica 5.04 issue that you have to try to set pos on something
			# before you get it for anything
			if not hasattr(self.net, '_posFix'):
				self.net._posFix = True
				# Add temp node, set its position, then remove it
				node = self.net.addNode('___kldfom234')
				node.position(0,0).remove()
			x = ctypes.c_double()
			y = ctypes.c_double()
			g.GetNodeVisPosition_bn(self.eId, None, ctypes.byref(x), ctypes.byref(y))
			return [x.value, y.value]
		else:
			g.SetNodeVisPosition_bn(self.eId, None, ctypes.c_double(x), ctypes.c_double(y))
			
			# Chain
			return self
	
	def size(self, width = None, height = None):
		if width is None:
			return [10, 10]
		else:
		
			# Chain
			return self

	def cpt1d(self, newCpt = None, parentStates = None):
		numEntries = self.numberStates()*self.net.numberCombinations(self.parents())

		if newCpt is None:
			if not g.HasNodeTable_bn(self.eId, None):
				return None
		
			pt = g.GetNodeProbs_bn(self.eId, parentStates)
			chkerr()
			
			if parentStates is not None:
				numEntries = self.numberStates()
			
			return [pt[i] for i in range(numEntries)]

		else:
			numStates = self.numberStates()
			
			rows = int(numEntries/numStates)
			
			# Normalisation
			for r in range(rows):
				r *= numStates
				totalRow = sum(newCpt[r:r+numStates])
				if totalRow:
					for i in range(r, r+numStates):
						newCpt[i] = newCpt[i]/totalRow
			
			nc = (ctypes.c_float*len(newCpt))(*newCpt)
			
			g.SetNodeProbs_bn(self.eId, None, nc)
			chkerr()
		
		# Chain
		return self
	
	
	#OW 09/08/21: seems to break when table is empty.  need a fix?
	def cpt(self, newCpt = None, parentStates = None):
		if newCpt is None:
			cpt1d = self.cpt1d()
			numStates = self.numberStates()

			def chunks(l, n):
				return [l[i:i+n] for i in range(0, len(l), n)]

			cpt = chunks(cpt1d, numStates)

			return cpt
		else:
			self.cpt1d(list(itertools.chain(*newCpt)), parentStates = parentStates)
		
		# Chain
		return self
	
	def user(self):
		return UserProperties(self)
		
	def setUniform(self):
		numEntries = self.numberStates()*self.net.numberCombinations(self.parents())
		self.cpt1d([float(1)/self.numberStates() for i in range(numEntries)])
		
		# Chain
		return self
	
	def setRandom(self):
		newCpt = []
		for r in range(self.net.numberCombinations(self.parents())):
			randVec = normalize([random.random() for v in range(self.numberStates())])
			newCpt.append(randVec)
		
		self.cpt(newCpt)
		
		# Chain
		return self
	
	def remove(self):
		g.DeleteNode_bn(self.eId)
		chkerr()
		
		return self

class UserProperties(object):
	NODE, NET = range(1,3)
	def __init__(self, entity):
		if hasattr(entity, 'eId'):
			self.eId = entity.eId
			self.type = self.NODE
		else:
			self.eId = entity.eNet
			self.type = self.NET
		
	def add(self, name, value):
		# SM: need to convert value from unicode into ascii
		value = bytes(value, encoding='ascii')
		if self.type == self.NODE:
			g.SetNodeUserField_bn(self.eId, name, value, len(value), 0)
		else:
			g.SetNetUserField_bn(self.eId, name, value, len(value), 0)

	##OW fix 13/01/21
	##self.eId -> self.node.eId
	##SM 6/6/22
	##and back, because generalised to net or nodes
	def get(self, name):
		# Will return null terminated string if absent; return 'None' in that case
		if self.type == self.NODE:
			return str(g.GetNodeUserField_bn(self.eId, name, None, 0)) or None
		else:
			return str(g.GetNetUserField_bn(self.eId, name, None, 0)) or None
	
	def delete(self, name):
		# Empty string equivalent to absent
		self.add(name, '')

class State(object):
	def __init__(self, node = None, stateNum = None):
		self.node = node
		self.stateNum = stateNum
	
	def name(self, _name = None):
		#rint(self.node.name(), _name)
		if _name is None:
			return g.GetNodeStateName_bn(self.node.eId, self.stateNum)
		else:
			g.SetNodeStateName_bn(self.node.eId, self.stateNum, _name)
		
			# Chain
			return self

	def title(self, _title = None):
		if _title is None:
			return g.GetNodeStateTitle_bn(self.node.eId, self.stateNum)
		else:
			g.SetNodeStateTitle_bn(self.node.eId, self.stateNum, _title)
		
			# Chain
			return self

	def setTrueFinding(self):
		g.RetractNodeFindings_bn(self.node.eId)
		g.EnterFinding_bn(self.node.eId, self.stateNum)
		chkerr()
